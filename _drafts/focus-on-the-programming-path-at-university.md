---
layout: post
title: A focus on the programming roadmap at University
---

Almost six years ago I was attending my first class of programming at University of Oviedo. In there, the professor Daniel Gayo gave us a read from Mario Mendoza's "Una escalera al cielo" which he used for explaining that programming (as many other fields) is a long race, a marathon, that only after several years of deep dedication and **practice** it will show you the first results and benefits for that effort.

My first contact in programming was using the Java programming language. What I like from Java for being the preferred language at that time was the compiler help. It was really helpful for guiding us to fix the typos and errors in our first hacks. But, on the other hand, I remember how the professors had to fight with all the complexity needed for starting to write a small application in Java without the need of explaining us all the concepts that are related with the input/output streamings, exceptions, objects, built-in types, etc.

Right now, I am pretty happy to see how [Python is the programming language used to explain the programming initial concepts](http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-popular-introductory-teaching-language-at-top-us-universities/fulltext) by using its clear and well-structured syntax, but, looking at the **University's table of contents** from the perspective of a 2-years-working software engineer, I see that there are several caveats that we should fill for building a better software engineers in the future.

### Testing culture

I'm right now facing my first professional experience working as a full-time developer and I'm trying to adopt TDD as my professional workflow for coding. For me is frustrating to see how every year a bunch of software engineers come out from the University to the TIC environment and we do not know almost nothing about the benefits of testing (not only Unit Test but Integration, Acceptance, etc.) and we are enforced to learn it at work, with the pressure of estimates and the need of having to have our work finished in a strict period of time.

### Ruby

### Real Object Oriented Design

### Functional Programming

### Design Patterns
