---
layout: post
title: A focus on the programming roadmap at University
---

Almost six years ago I was attending my first class of programming at University of Oviedo. In there, the professor Daniel Gayo ([@PFCdgayo](https://twitter.com/PFCdgayo)) gave us a read from Mario Mendoza's "Una escalera al cielo" which he used for explaining that programming (as many other fields) is a long race, a marathon, that only after several years of deep dedication and **practice** it will show you the first results and benefits for that effort.

My first contact in programming was using the Java programming language. What I like from Java for being the preferred language at that time was the compiler help. It was really helpful for guiding us to fix the typos and errors in our first hacks. But, on the other hand, I remember how the professors had to fight with all the complexity needed for starting to write a small application in Java without the need of explaining us all the concepts that are related with the input/output streamings, exceptions, objects, built-in types, etc.

Right now, I am pretty happy to see how [Python is the programming language used to explain the programming initial concepts](http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-popular-introductory-teaching-language-at-top-us-universities/fulltext) by using its clear and well-structured syntax, but, looking at the **University's table of contents** from the perspective of a junior software engineer with just 2 years of working experience, I see that there are several caveats that we should fill for building a better software engineers in the future.

### Testing culture

I'm right now facing my first professional experience working as a full-time developer and I'm trying to adopt TDD as my professional workflow for coding. For me is frustrating to see how every year a bunch of software engineers come out from the University to the IT environment and we don't know almost nothing about the benefits of testing (not only Unit Test but Integration, Acceptance, etc.) and we are enforced to learn it at work, with the pressure of estimations and the need of having to have our work finished in a strict period of time.

IMHO this is a very crucial point for making the software development process better in the future. Right now, we live in a world commanded by software and the future engineers must be correctly taught for not repeating the past errors.

### Real Object Oriented Design

When I came out from the University I was pretty conviced that I knew almost everything about object oriented software. I know that we should extract the most important parts of the domain problem on its own objects and make them interact for building the entire software. But that idea was very vague. Object Oriented design is more that having just the neccesary items for building the software and it is about testing and protocols for exchanging messages.

I think the best way for showing this idea is by using a real example from some of my programming exercises on the first year @ University:

### Functional Programming

During my studies at University I didn't have the opportunity for learning any functional programming language (beyond some Prolog during the first semester of the first year...) and these last months working with Scala by doing my Master Thesis were really enriching. I learnt the benefits of writing code with functions without side effects, the use of methods such as `map`, `reduce` or `zip` for working with collections and closures.

All this work have made me think in a different manner when I'm facing some problems at work and use the functional parts of programming languages as Javascript or Ruby for resolving the required tasks.


### Design Patterns
